var jsonLSP = require('vscode-json-languageservice');
var getSchema = require('./getSchema.js');
var neoAppValidatorUtil = require('./neoApp/neoAppValidator.js');
var _ = require('lodash');
var fs = require('fs');
var Q = require('q');
var path = require('path');

var vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
var fioriSchemaProvider = require("./manifest/utils/fioriSchemaProvider.js");
var JSONValidator = jsonLSP.getLanguageService({
    schemaRequestService: null,
    workspaceContext: "./",
    contributions: []
});


var SEVERITY  = {
        1: "error",
        2: "warning",
        3: "information",
        4: "hint"
};

function validateFiles(validationMetadata, fileResources) {
    var aPromises = [];

    var oSettings = getSettings();
    JSONValidator.configure(oSettings.json);

    fileResources.forEach(function(fileResource){
        aPromises.push(singleFileValidationHandler(fileResource));
    });

    return Q.all(aPromises).then(function(aProblems){
        return {issues: _.flatten(aProblems)};
    })
}

function singleFileValidationHandler(fileResource){
    var jsonDocument = JSONValidator.parseJSONDocument(fileResource);
    var fileContent = fs.readFileSync(fileResource.filePath).toString();
    var textDocument = vscode_languageserver_protocol_1.TextDocument.create(fileResource.filePath, "json", 0, fileContent);
    var documentSettings = textDocument.languageId === 'jsonc' ? {
        comments: 'ignore',
        trailingCommas: 'ignore'
    } : {comments: 'error', trailingCommas: 'error'};

    return JSONValidator.doValidation(textDocument, jsonDocument, documentSettings).then(function (diagnostics){
        return resultHandler(diagnostics, fileResource);
    });
}

function resultHandler (diagnostics, fileResource) {
    var issues = [];
    diagnostics.forEach(function(diagnostic) {
        var issue ={
            range : diagnostic.range,
            checker : "",
            category : "Syntax Error",
            column: diagnostic.range.start.character + 1,
            line: diagnostic.range.start.line + 1,
            message: diagnostic.message,
            path: fileResource.filePath,
            ruleId : "",
            severity: SEVERITY[diagnostic.severity]
        };
        issues.push(issue);
    });
    return issues;
}

function getManifestURL(curPath){
    var files = fs.readdirSync(curPath);
    for(var i=0; i < files.length; i++){
        var file = files[i];
        if (file === 'manifest.json'){
            return path.join(curPath, "manifest.json");
        }
        var newPath = path.join(curPath,file);
        if (file != 'dist' && file != 'node_modules' && fs.lstatSync(newPath).isDirectory()){
            var foundPath = getManifestURL(newPath);
            if (foundPath) {
                return foundPath;
            }
        }
    }
};

function getSettings(){
    var oNeoAppSchema = neoAppValidatorUtil.getSchema();
    var oManifestFileURL = getManifestURL(process.cwd());
    if (oManifestFileURL){
        var parsedManifest = getSchema._getRemoteResource(oManifestFileURL);
        var oManifestSchema = fioriSchemaProvider.getSchema(parsedManifest);
    }

    var JSONSchemaSettings = [{
        fileMatch: ["neo-app.json"],
        schema: oNeoAppSchema,
        uri: "neo-app.json"
    }
    ,{
        fileMatch: ["manifest.json"],
        schema: oManifestSchema,
        uri:"manifest.json"
    }
    ];
    var oSettings = {
        json: {
            schemas: JSONSchemaSettings,
            validate: true
        }
    };
    return oSettings;
}

module.exports = {
    validateFiles: validateFiles
};
