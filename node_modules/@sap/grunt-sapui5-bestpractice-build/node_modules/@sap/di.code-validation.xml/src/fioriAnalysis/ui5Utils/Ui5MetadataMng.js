if (typeof define !== 'function') {var define = require('amdefine')(module)};
var fs = require("fs");
var path = require("path");
var DataType = require("./sap.ui.base/DataType");

define(["./EnumValue", "./Utils"], function(EnumValue, Utils) {
	//var JSZip = require("jszip");

    "use strict";

    //it contain all the UI5 library information by the version, 
    var _mMeta = {};
    var _mMetaVersion = '1.48.5';

    //!!now the UI5 control/element metadata not contain the Aggregation for Element, as it is very stable, so just 
    //put the static value here for performance
    var _mElementAggr= {
        customData: {
            Deprecated: false,
            multiple: true,
            type: "sap.ui.core.CustomData"
        }, 
        dependents: {
            Deprecated: false,
            multiple: true,
            type: "sap.ui.core.Control"
        },
        layoutData: {
            Deprecated: false,
            multiple: false,
            type: "sap.ui.core.LayoutData"
        },
        tooltip: {
            Deprecated: false,
            multiple: false,
            type: "sap.ui.core.TooltipBase"
        }
    };

    var _mControlProp = {
        busy: {
            Deprecated: false,
            type: "boolean",
            defaultValue: false
        },
        busyIndicatorDelay: {
            Deprecated: false,
            defaultValue: "1000",
            type: "int"
        },
        visible: {
            Deprecated: false,
            defaultValue: true,
            type: "boolean"
        }
    };

    var defaultCheckLib = [
        "sap.m.json",
        "sap.ui.core.json",
        "sap.ui.commons.json",
        "sap.ui.table.json",
        "sap.ui.layout.json",
        "sap.ui.comp.json",
        "sap.uxap.json"
    ];

    return {

        _getSapUi5Version : function (aDependencies){
            //find the sapui5 entry and read version
            for(var ii=0; ii < aDependencies.length; ii++){
                var oDependency = aDependencies[ii];
                var name = oDependency.library;
                if(name === "sapui5"){
                    return oDependency.version;
                }
            }
        },

    	/**
    	 * load the UI5 metadata from server by version
    	 * @param  {[type]} libInfo : a map, like {version: '1.29',  librarys: 'sap.m, sap.ui.table'}
    	 *                        for the librarys, need confirm with UI5  team whether can return all the library separately or together
    	 * @return {[type]}         [description]
    	 */
    	loadMetadata: function( libInfo, oContext ) {
    	    //first check whether it has been loaded,
            /*var version = this._getSapUi5Version(libInfo);
            var metadataPromise = Q.defer();
            var that = this;
    	    return oContext.service.librarymetadata.getMetadata("sapui5", "xml", version)
                .then(
                function(data) {
                    return that._onLoadZipSuccess(data, libInfo);
                }
            );*/
			
			
			function readFiles(dirname, onFileContent, onError) {
				var filenames = fs.readdirSync(dirname);
				filenames.forEach(function(filename) {
					var content = fs.readFileSync(dirname + '/' + filename);
					onFileContent(filename, content);				  
				});
			}
			function merge(objs) {
				var obj = {},
					i = 0,
					il = objs.length,
					key;
				var num = 0;
				for (; i < il; i++) {
					for (key in objs[i]) {
							num++;
						if (objs[i].hasOwnProperty(key)) {
							obj[key] = objs[i][key];
						}
					}
				}
				return obj;
			}
			
			_mMeta[_mMetaVersion] = {
					enums: {},
					metadatas: {} 
			};
			var metas = [];
			var enums = [];
            var ui5VersionLocation = path.join(__dirname, '..', 'ui5Versions', _mMetaVersion);
			readFiles(ui5VersionLocation, function (filename, content) {
				var json = JSON.parse(content);
				metas.push(json.metadatas || []);
				enums.push(json.enums || []);
			}, function(err) { throw err});
			_mMeta[_mMetaVersion].metadatas = merge(metas);
			_mMeta[_mMetaVersion].enums = merge(enums);
			//throw Object.keys(_mMeta[_mMetaVersion].metadatas);
			return {
                version: _mMetaVersion,
                metadata: _mMeta[_mMetaVersion]
            };
			
			
			
			
			/*var that = this;
			var data = fs.readFileSync(__dirname + '/ui5Response.json', 'utf8');
			var zip = new JSZip();
			zip.file("sap.ui.core.json", data);
			var data = {metadata : zip, version:_mMetaVersion};
			return that._onLoadZipSuccess(data);*/
			
    	},

        /**
         * Get metadata for the control or element
         * 
         * @param  {[type]} mMetadata:  The metadata for the project UI5 version
         * @param  {[type]} controlOrElementName 
         * @return {[type]} The UI5 metadata for the control or element name
         */
        getMetadataByName: function( mMetadata, controlOrElementName) {
            return mMetadata.metadatas[ controlOrElementName ];
        },
        
        /**
         * Get the aggregation metadata for the controls's aggregation name
         * @param  {[type]} mMetadata            [description]
         * @param  {[type]} controlOrElementName [description]
         * @param  {[type]} aggregationNodeName  [description]
         * @return {[type]}                      [description]
         */
        getAggregationMetadata:function( mMetadata, controlOrElementName, aggregationNodeName ) {
            if (mMetadata.metadatas[ controlOrElementName]) {
                //Now the aggregations not contain the Element part, so need add here
                var mAggr = mMetadata.metadatas[ controlOrElementName][ "aggregations"];
                if (aggregationNodeName in mAggr) {
                    return mAggr[aggregationNodeName];
                } else {
                    //Try to get from the Element 
                    return _mElementAggr[ aggregationNodeName];
                }
            }

            return null;
        },

        /*
         * Check whether it is a valid aggregation name or not
         */
        isValidAggregationName: function( mMetadata, controlOrElementName, aggregationNodeName) {
            var md = this.getAggregationMetadata(mMetadata, controlOrElementName, aggregationNodeName);
            if (md == null) {
                //if parent can't find the metadata, then no need check
                var controlMeta = this.getMetadataByName(mMetadata, controlOrElementName);
                if (!controlMeta){
                    return true;
                }
                else{
                    return false;
                }
            } else {
                return true;
            }
        },

        /*
         * Check whether the aggregation is deprecated or not
         */
        isAggregationDeprecated: function( mMetadata, controlOrElementName, aggregationNodeName) {
            var md = this.getAggregationMetadata(mMetadata, controlOrElementName, aggregationNodeName);
            if (md && md.DeprecatedInfo) {
                return md.DeprecatedInfo;
            } else {
                return {
                    isDeprecated: false
                };
            }
        },

        /*
         * Check whether teh control is deprecated or not
         */
        isControlDeprecated: function( mMetadata, controlOrElementName) {
            var md = mMetadata.metadatas[ controlOrElementName ];
            if (md && md.DeprecatedInfo) {
                return md.DeprecatedInfo;
            } else {
                return {
                    isDeprecated: false
                };
            }
        },

        /**
         * Private function: check whether the control is instance of the type name
         * @param  {[type]}  mMetadata [description]
         * @param  {[type]}  ctrlName  [description]
         * @param  {[type]}  typeName  [description]
         * @return {Boolean} : true if is instance of, otherwise false     
         */
        _isInstanceOf: function(mMetadata, ctrlName, typeName) {
            //!!some is interface, but now UI5 metadata not support it , so currently need ignore it 
            var md = this.getMetadataByName(mMetadata, typeName);
            if (!md){
                return true;
            }
            //first check itself, if not then check it's parent extend: "sap.ui.core.Control"
            if (ctrlName == typeName) {
                return true;
            } else {
                //only reach to the topMost class: "sap.ui.core.Element" for performance
                if ( ctrlName != EnumValue.StrElement) {
                    var md = this.getMetadataByName(mMetadata, ctrlName);
                    if (md) {
                        var extend = md.extend;
                        return this._isInstanceOf(mMetadata, extend, typeName);
                    } else {
                        //!! if can't get that,then by default just ignore it
                        return true;
                    }
                }
            }

            return false;
        },
        
        /**
         * Check whether the control is a validate candidate for a control's aggregation, 
         *      such as for the Table, the sap.ui.table.Column is a valid candidate for the Columns aggregation node
         * @param  {[type]}  mMetadata            [description]
         * @param  {[type]}  controlOrElementName [description]
         * @param  {[type]}  aggregationNodeName  [description]
         * @param  {[type]}  candidateName        [description]
         * @return {Boolean}                      [description]
         */
        isValidAggregationCandidate: function( mMetadata, controlOrElementName, aggregationNodeName, candidateName) {
            var md = this.getAggregationMetadata(mMetadata, controlOrElementName, aggregationNodeName); 
            //now candidateName like sap.ui.table.TreeTable,  
            if (md) {
                //type like sap.ui.table.Table
                var type = md.type; 

                return this._isInstanceOf(mMetadata, candidateName, type);
            }

            return false;            
        },
        
        

        /**
         * Get the meta data type ( Agrr, Prop, Asso,Event ) and the meta data 
         * @param  {[type]} mMetadata            [description]
         * @param  {[type]} controlOrElementName [description]
         * @param  {[type]} metaName             [description]
         * @return {[type]} : {
         *                    metaType: value in EnumValue.MetaType,
         *                    metaData: the map of the detail property of the Prop/Event/Asso
         *                    }
         */
        getMetaTypeAndMetaData: function( mMetadata, controlOrElementName, metaName ) {
            var md = mMetadata.metadatas[ controlOrElementName];

            var ret = {
                metaType: EnumValue.MetaType.Unknown,
                metaData: null
            };

            if ( !md) {
                return ret;
            }

            //first try to get from itself, if not then find from parent,until reach to the Control or element
            if ( metaName in md.properties) {
                ret.metaType = EnumValue.MetaType.Prop ; 
                ret.metaData = md.properties[ metaName];
            } else if (metaName in md.aggregations) {
                ret.metaType = EnumValue.MetaType.Aggr ;
                ret.metaData = md.aggregations[ metaName]; 
            } else if (metaName in md.associations) {
                ret.metaType = EnumValue.MetaType.Asso ; 
                ret.metaData = md.associations[ metaName]; 
            } else if (metaName in md.events) {
                ret.metaType = EnumValue.MetaType.Event ; 
                ret.metaData = md.events[ metaName]; 
            }

            if (ret.metaType != EnumValue.MetaType.Unknown) {
                return ret;    
            } else {
                //try to get from parent, until reach to top most
                if ( controlOrElementName == EnumValue.StrManagedObject) {
                    //still can't find, no need check parent any more
                    return ret;
                } else {
                    var parentName = md.extend;
                    return this.getMetaTypeAndMetaData(mMetadata, parentName, metaName);
                }
            }
        },
    
        /**
         * Check the semantic of the property value, mainly based on the metadata type
         * @param  {[type]} name        : property name
         * @param  {[type]} value       : property value
         * @param  {[type]} propMeta    : the meta data for the property
         * @param  {[type]} controlMeta : the meta dat for the control, it is needed when do the auto fix
         * @param  {[type]} mMetadata: The metadata for current version
         * @return {[type]}           return [] means no error, else return the array: [msgId, arg0, arg1, arg2, arg3]
         */
        checkPropertyValue : function(name, oValue, propMeta, controlMeta, mMetadata) {
            //Here check for the enum value first
            if (  Utils.startsWith( propMeta.type, "sap.") ) {
                var mEnum = mMetadata.enums[ propMeta.type ];
                //some basic type like the sap.ui.core.CSSSize will not find in enums, so it will do the normal check
                if (mEnum) {
                    //here normal case is a enum value not correct, then we also try to get the correct value
                    if ( oValue in mEnum) {
                        return [];
                    } else {
                        //Invalid property value <{0}> for enum type <{1}> of property <{3}>. 
                        //!!here can use the string similary check to get the most matched case
                        return ["XML_INVALID_PROPERTY_ENUM_VALUE", oValue, propMeta.type, name];
                    }
                }
            }

            var oType = DataType.getType(propMeta.type);

            // If property has an array type, clone the array to avoid modification of original data
           /* if (oType instanceof sap.ui.base.DataType && oType.isArrayType() && jQuery.isArray(oValue)) {
                oValue = oValue.slice(0);
            }*/

            // In case null is passed as the value return the default value, either from the property or from the type
            if (oValue === null || oValue === undefined) {
                //just pass
            } else if (oType instanceof DataType) {
                // Implicit casting for string only, other types are causing errors

                if (oType.getName() == "string") {
                    // if (!(typeof oValue == "string" || oValue instanceof String)) {
                    //  oValue = "" + oValue;
                    // }
                } else if (oType.getName() == "string[]") {
                    // For compatibility convert string values to array with single entry
                    // if (typeof oValue == "string") {
                    //     oValue = [oValue];
                    // }
                    // if (!jQuery.isArray(oValue)) {
                    //     //Invalid property value: {0} is type {1}, expected {2} for property {3}. Please enter the correct value for the mode type. 
                    //     return ["XML_INVALID_PROPERTY_VALUE", oValue, typeof oValue, "string[]", name];
                    // }
                } else  {
                    //here the value is string like "true", so need covnert to to the corresponding data type,
                    var  parsedValue = null; 
                    //but for the enum type can't use the parseValue as it will return null, then the prompt willl lost real value 
                    if (  Utils.startsWith( propMeta.type, "sap.") ) {
                        // if (parseValue == null) {
                        //  parseValue = oValue;
                        // }
                        parsedValue = oValue;
                    } else {
                        parsedValue = oType.parseValue(oValue);
                    }

                    //??need check for the enum value
                    if ( !oType.isValid(parsedValue) ) {
                        //here normal case is a enum value not correct, then we also try to get the correct value 
                        return ["XML_INVALID_PROPERTY_VALUE", oValue, typeof oValue, oType.getName() , name];
                    }
                }
            }

            return [];
        },

        _isNeedCheckedLib : function( fileName ) {
            for (var i=0; i < defaultCheckLib.length; i++) {
                //as the file name may contain _ or not, so just juse indexOf to match
                if (fileName.indexOf(defaultCheckLib[i]) != -1){
                    return true;
                }
            }
            return false;
        },

    	_onLoadZipSuccess: function( zipContent ) {
			var version = zipContent.version;
			if ( ! (version in _mMeta)) {
				_mMeta[version] = {
					enums: {},
					metadatas: {} 
					};
			}
            var metadata = zipContent.metadata;
			for (var fileName in metadata.files) {
				//??here need check from the libInfo to know which library need parse or not  _sap.m.json
				//??now just parse the mobile library
                //??here need check from the libInfo to know which library need parse or not  sap.m.json
                //??now just parse the default mobile library
                if (this._isNeedCheckedLib(fileName)) {
					var content = metadata.files[fileName].asText();
					try {
						var json = JSON.parse(content);
						//just merge 
						//jQuery.extend( true, _mMeta[version], json);
						_mMeta[version] = json;//TODO
					} catch(ex) {
						throw new Error("File content " + fileName + " is invalida");
					}
				}
			}
			//now all library load, so can return
			return _mMeta[version] ;
    	}
    	    	
    };
});